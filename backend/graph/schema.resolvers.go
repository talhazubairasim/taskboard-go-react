package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"
	"time"

	"taskboard/graph/model"
	"taskboard/internal/auth"
	"taskboard/internal/cache"
	"taskboard/internal/models"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	// Check if email already exists
	exists, err := r.userRepo.EmailExists(ctx, input.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to check email: %w", err)
	}
	if exists {
		return nil, fmt.Errorf("email already registered")
	}

	// Hash password
	hash, err := auth.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Create user
	user := &models.User{
		Email:        input.Email,
		PasswordHash: hash,
		Name:         input.Name,
	}

	user, err = r.userRepo.Create(ctx, user)
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Generate tokens
	accessToken, err := r.jwtManager.GenerateAccessToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate access token: %w", err)
	}

	refreshToken, err := r.jwtManager.GenerateRefreshToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate refresh token: %w", err)
	}

	return &model.AuthPayload{
		Token:        accessToken,
		RefreshToken: refreshToken,
		User:         toGraphQLUser(user),
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	// Get user by email
	user, err := r.userRepo.GetByEmail(ctx, input.Email)
	if err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Check password
	if err := auth.CheckPassword(input.Password, user.PasswordHash); err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Generate tokens
	accessToken, err := r.jwtManager.GenerateAccessToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate access token: %w", err)
	}

	refreshToken, err := r.jwtManager.GenerateRefreshToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate refresh token: %w", err)
	}

	return &model.AuthPayload{
		Token:        accessToken,
		RefreshToken: refreshToken,
		User:         toGraphQLUser(user),
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.AuthPayload, error) {
	// Validate refresh token
	claims, err := r.jwtManager.ValidateRefreshToken(refreshToken)
	if err != nil {
		return nil, fmt.Errorf("invalid refresh token")
	}

	// Get user
	user, err := r.userRepo.GetByID(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Generate new tokens
	newAccessToken, err := r.jwtManager.GenerateAccessToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate access token: %w", err)
	}

	newRefreshToken, err := r.jwtManager.GenerateRefreshToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate refresh token: %w", err)
	}

	return &model.AuthPayload{
		Token:        newAccessToken,
		RefreshToken: newRefreshToken,
		User:         toGraphQLUser(user),
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input model.CreateTaskInput) (*model.Task, error) {
	claims, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	status := model.TaskStatusTodo
	if input.Status != nil {
		status = *input.Status
	}

	priority := model.PriorityMedium
	if input.Priority != nil {
		priority = *input.Priority
	}

	task := &models.Task{
		Title:       input.Title,
		Description: input.Description,
		Status:      string(status),
		Priority:    string(priority),
		CreatedByID: claims.UserID,
	}

	if input.AssignedToID != nil {
		task.AssignedToID = input.AssignedToID
	}

	if input.DueDate != nil {
		task.DueDate = input.DueDate
	}

	task, err = r.taskRepo.Create(ctx, task)
	if err != nil {
		return nil, fmt.Errorf("failed to create task: %w", err)
	}

	// Invalidate cache
	if r.cache != nil {
		r.cache.DeletePattern(ctx, "tasks:*")
	}

	// Get task with relations
	return r.getTaskWithRelations(ctx, task.ID)
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, input model.UpdateTaskInput) (*model.Task, error) {
	claims, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Get existing task
	existingTask, err := r.taskRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	// Check ownership
	if existingTask.CreatedByID != claims.UserID {
		return nil, fmt.Errorf("unauthorized: you can only update your own tasks")
	}

	// Build updates map
	updates := make(map[string]interface{})
	if input.Title != nil {
		updates["title"] = *input.Title
	}
	if input.Description != nil {
		updates["description"] = input.Description
	}
	if input.Status != nil {
		updates["status"] = string(*input.Status)
	}
	if input.Priority != nil {
		updates["priority"] = string(*input.Priority)
	}
	if input.AssignedToID != nil {
		updates["assigned_to_id"] = input.AssignedToID
	}
	if input.DueDate != nil {
		updates["due_date"] = input.DueDate
	}

	task, err := r.taskRepo.Update(ctx, id, updates)
	if err != nil {
		return nil, fmt.Errorf("failed to update task: %w", err)
	}

	// Invalidate cache
	if r.cache != nil {
		r.cache.Delete(ctx, cache.TaskKey(id))
		r.cache.DeletePattern(ctx, "tasks:*")
	}

	return r.getTaskWithRelations(ctx, task.ID)
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	claims, err := auth.RequireAuth(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthorized")
	}

	// Get task to check ownership
	task, err := r.taskRepo.GetByID(ctx, id)
	if err != nil {
		return false, fmt.Errorf("task not found")
	}

	if task.CreatedByID != claims.UserID {
		return false, fmt.Errorf("unauthorized: you can only delete your own tasks")
	}

	err = r.taskRepo.Delete(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete task: %w", err)
	}

	// Invalidate cache
	if r.cache != nil {
		r.cache.Delete(ctx, cache.TaskKey(id))
		r.cache.DeletePattern(ctx, "tasks:*")
	}

	return true, nil
}

// AssignTask is the resolver for the assignTask field.
func (r *mutationResolver) AssignTask(ctx context.Context, taskID string, userID string) (*model.Task, error) {
	_, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Verify user exists
	_, err = r.userRepo.GetByID(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	updates := map[string]interface{}{
		"assigned_to_id": &userID,
	}

	task, err := r.taskRepo.Update(ctx, taskID, updates)
	if err != nil {
		return nil, fmt.Errorf("failed to assign task: %w", err)
	}

	// Invalidate cache
	if r.cache != nil {
		r.cache.Delete(ctx, cache.TaskKey(taskID))
		r.cache.DeletePattern(ctx, "tasks:*")
	}

	return r.getTaskWithRelations(ctx, task.ID)
}

// UnassignTask is the resolver for the unassignTask field.
func (r *mutationResolver) UnassignTask(ctx context.Context, taskID string) (*model.Task, error) {
	_, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	updates := map[string]interface{}{
		"assigned_to_id": nil,
	}

	task, err := r.taskRepo.Update(ctx, taskID, updates)
	if err != nil {
		return nil, fmt.Errorf("failed to unassign task: %w", err)
	}

	// Invalidate cache
	if r.cache != nil {
		r.cache.Delete(ctx, cache.TaskKey(taskID))
		r.cache.DeletePattern(ctx, "tasks:*")
	}

	return r.getTaskWithRelations(ctx, task.ID)
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, name *string, avatar *string) (*model.User, error) {
	claims, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	updates := make(map[string]interface{})
	if name != nil {
		updates["name"] = *name
	}
	if avatar != nil {
		updates["avatar"] = avatar
	}

	user, err := r.userRepo.Update(ctx, claims.UserID, updates)
	if err != nil {
		return nil, fmt.Errorf("failed to update profile: %w", err)
	}

	// Invalidate cache
	if r.cache != nil {
		r.cache.Delete(ctx, cache.UserKey(claims.UserID))
	}

	return toGraphQLUser(user), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	claims, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	user, err := r.userRepo.GetByID(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return toGraphQLUser(user), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, err := r.userRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return toGraphQLUser(user), nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.userRepo.List(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list users: %w", err)
	}

	var result []*model.User
	for _, user := range users {
		result = append(result, toGraphQLUser(user))
	}

	return result, nil
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	return r.getTaskWithRelations(ctx, id)
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, filter *model.TaskFilterInput) ([]*model.Task, error) {
	filterMap := make(map[string]interface{})
	
	if filter != nil {
		if filter.Status != nil {
			filterMap["status"] = string(*filter.Status)
		}
		if filter.Priority != nil {
			filterMap["priority"] = string(*filter.Priority)
		}
		if filter.AssignedToID != nil {
			filterMap["assigned_to_id"] = *filter.AssignedToID
		}
		if filter.CreatedByID != nil {
			filterMap["created_by_id"] = *filter.CreatedByID
		}
	}

	tasks, err := r.taskRepo.List(ctx, filterMap)
	if err != nil {
		return nil, fmt.Errorf("failed to list tasks: %w", err)
	}

	var result []*model.Task
	for _, task := range tasks {
		graphqlTask, err := r.taskToGraphQL(ctx, task)
		if err != nil {
			return nil, err
		}
		result = append(result, graphqlTask)
	}

	return result, nil
}

// MyTasks is the resolver for the myTasks field.
func (r *queryResolver) MyTasks(ctx context.Context) ([]*model.Task, error) {
	claims, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	tasks, err := r.taskRepo.GetByUserID(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get tasks: %w", err)
	}

	var result []*model.Task
	for _, task := range tasks {
		graphqlTask, err := r.taskToGraphQL(ctx, task)
		if err != nil {
			return nil, err
		}
		result = append(result, graphqlTask)
	}

	return result, nil
}

// AssignedTasks is the resolver for the assignedTasks field.
func (r *queryResolver) AssignedTasks(ctx context.Context) ([]*model.Task, error) {
	claims, err := auth.RequireAuth(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	tasks, err := r.taskRepo.GetAssignedToUser(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get assigned tasks: %w", err)
	}

	var result []*model.Task
	for _, task := range tasks {
		graphqlTask, err := r.taskToGraphQL(ctx, task)
		if err != nil {
			return nil, err
		}
		result = append(result, graphqlTask)
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Helper functions

func toGraphQLUser(user *models.User) *model.User {
	return &model.User{
		ID:        user.ID,
		Email:     user.Email,
		Name:      user.Name,
		Avatar:    user.Avatar,
		CreatedAt: user.CreatedAt,
		UpdatedAt: user.UpdatedAt,
	}
}

func (r *Resolver) taskToGraphQL(ctx context.Context, task *models.Task) (*model.Task, error) {
	// Get creator
	creator, err := r.userRepo.GetByID(ctx, task.CreatedByID)
	if err != nil {
		return nil, fmt.Errorf("failed to get creator: %w", err)
	}

	graphqlTask := &model.Task{
		ID:          task.ID,
		Title:       task.Title,
		Description: task.Description,
		Status:      model.TaskStatus(task.Status),
		Priority:    model.Priority(task.Priority),
		CreatedBy:   toGraphQLUser(creator),
		DueDate:     task.DueDate,
		CreatedAt:   task.CreatedAt,
		UpdatedAt:   task.UpdatedAt,
	}

	// Get assignee if exists
	if task.AssignedToID != nil {
		assignee, err := r.userRepo.GetByID(ctx, *task.AssignedToID)
		if err == nil {
			graphqlTask.AssignedTo = toGraphQLUser(assignee)
		}
	}

	return graphqlTask, nil
}

func (r *Resolver) getTaskWithRelations(ctx context.Context, taskID string) (*model.Task, error) {
	task, err := r.taskRepo.GetByID(ctx, taskID)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	return r.taskToGraphQL(ctx, task)
}